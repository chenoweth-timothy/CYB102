<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Week 1: Interactive Network Topologies</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f7fafc;
        }
        .bg-college-red { background-color: #c8102e; }
        .text-college-red { color: #c8102e; }
        .border-college-red { border-color: #c8102e; }
        .hover-bg-college-red-dark:hover { background-color: #a20c24; }
        
        .control-btn {
            transition: all 0.2s ease-in-out;
        }
        .control-btn.active {
            background-color: #c8102e;
            color: white;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        }
        canvas {
            background-color: #fff;
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        }
        .info-panel {
            background-color: #fff;
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        }
    </style>
</head>
<body class="text-gray-800">

    <!-- Header -->
    <header class="bg-college-red shadow-md">
        <div class="max-w-7xl mx-auto py-4 px-4 sm:px-6 lg:px-8 flex justify-between items-center">
            <div>
                <h1 class="text-2xl font-bold text-white">Interactive Topologies</h1>
                <p class="text-white opacity-90 mt-1">Week 1: Introduction to Networking</p>
            </div>
            <a href="index.html" class="text-white font-medium hover:underline">&larr; Back to Course Hub</a>
        </div>
    </header>

    <!-- Main Content -->
    <main class="py-8">
        <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">

            <!-- Controls -->
            <div class="bg-white p-4 rounded-lg shadow-md mb-8">
                <h2 class="text-lg font-semibold mb-3 text-center sm:text-left">Select a Topology</h2>
                <div id="topology-buttons" class="grid grid-cols-2 sm:grid-cols-4 gap-4">
                    <button data-type="bus" class="control-btn p-3 rounded-md font-medium bg-gray-200 hover:bg-gray-300">Bus</button>
                    <button data-type="star" class="control-btn p-3 rounded-md font-medium bg-gray-200 hover:bg-gray-300">Star</button>
                    <button data-type="ring" class="control-btn p-3 rounded-md font-medium bg-gray-200 hover:bg-gray-300">Ring</button>
                    <button data-type="mesh" class="control-btn p-3 rounded-md font-medium bg-gray-200 hover:bg-gray-300">Mesh</button>
                </div>
            </div>

            <div class="flex flex-col lg:flex-row gap-8">
                <!-- Canvas Container -->
                <div class="w-full lg:w-2/3">
                    <canvas id="network-canvas"></canvas>
                    <div id="simulation-controls" class="mt-4 flex flex-wrap gap-4 items-center justify-center bg-white p-4 rounded-lg shadow-md">
                         <button id="send-packet-btn" class="bg-college-red text-white font-bold py-2 px-4 rounded hover-bg-college-red-dark transition-colors">Send Packet</button>
                         <button id="break-link-btn" class="bg-gray-600 text-white font-bold py-2 px-4 rounded hover:bg-gray-700 transition-colors">Break Component</button>
                         <button id="reset-btn" class="bg-gray-200 text-gray-700 font-bold py-2 px-4 rounded hover:bg-gray-300 transition-colors">Reset</button>
                    </div>
                </div>

                <!-- Information Panel -->
                <div class="w-full lg:w-1/3 info-panel p-6">
                    <h3 id="info-title" class="text-xl font-bold text-college-red mb-3">Select a topology to start</h3>
                    <p id="info-description" class="text-gray-600 mb-4">Use the buttons above to choose a network layout. Then, use the controls below the diagram to simulate traffic and component failures.</p>
                    <div id="info-pros-cons">
                        <!-- Pros and Cons will be injected here -->
                    </div>
                    <div id="simulation-status" class="mt-4 p-4 bg-gray-100 rounded-md min-h-[50px]">
                        <p class="font-medium text-gray-700">Status: <span id="status-text" class="font-normal">Ready</span></p>
                    </div>
                </div>
            </div>
        </div>
    </main>
    
    <script>
    document.addEventListener('DOMContentLoaded', () => {
        // --- DOM Elements ---
        const canvas = document.getElementById('network-canvas');
        const ctx = canvas.getContext('2d');
        const topologyButtons = document.getElementById('topology-buttons');
        const sendPacketBtn = document.getElementById('send-packet-btn');
        const breakLinkBtn = document.getElementById('break-link-btn');
        const resetBtn = document.getElementById('reset-btn');
        const infoTitle = document.getElementById('info-title');
        const infoDescription = document.getElementById('info-description');
        const infoProsCons = document.getElementById('info-pros-cons');
        const statusText = document.getElementById('status-text');

        // --- State ---
        let state = {
            topology: null,
            nodes: [],
            links: [],
            hub: null,
            packet: null,
            mode: 'normal', // 'normal', 'select-source', 'select-dest', 'break-link'
            animationFrameId: null,
            numNodes: 6,
        };

        const topologyInfo = {
            bus: {
                title: "Bus Topology",
                description: "All devices are connected to a single central cable, called the bus or backbone. Data is sent to all devices, but only the intended recipient accepts and processes it.",
                pros: ["Easy to implement and extend.", "Requires less cable than other topologies."],
                cons: ["If the main cable fails, the entire network shuts down.", "Performance degrades as more devices are added.", "Difficult to troubleshoot."]
            },
            star: {
                title: "Star Topology",
                description: "All devices are connected to a central hub or switch. Each device has a dedicated point-to-point connection to the central device.",
                pros: ["Easy to install and manage.", "Failure of a single node or cable does not affect the rest of the network.", "Easy to detect faults."],
                cons: ["If the central hub fails, the entire network fails.", "Requires more cable than a bus topology.", "Costlier due to the central device."]
            },
            ring: {
                title: "Ring Topology",
                description: "Each device is connected to exactly two other devices, forming a single continuous pathway for signals through each node - a ring. Data travels from node to node, in one direction.",
                pros: ["Performs better than a bus topology under heavy load.", "Prevents network collisions."],
                cons: ["Failure of one node or cable can break the loop and take down the entire network.", "Difficult to add or remove devices.", "Troubleshooting is difficult."]
            },
            mesh: {
                title: "Mesh Topology",
                description: "Every device is connected to every other device. This topology can be a full mesh (all devices connected) or a partial mesh (some devices are fully connected).",
                pros: ["Extremely reliable and robust; failure of one link doesn't affect the network.", "Provides security and privacy.", "Fault detection is easy."],
                cons: ["Very expensive and complex due to the amount of cabling and connections required.", "Difficult to install and reconfigure."]
            }
        };

        // --- Icons (as SVG strings) ---
        const computerIcon = new Image();
        computerIcon.src = `data:image/svg+xml,${encodeURIComponent(`<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-monitor"><rect x="2" y="3" width="20" height="14" rx="2" ry="2"></rect><line x1="8" y1="21" x2="16" y2="21"></line><line x1="12" y1="17" x2="12" y2="21"></line></svg>`)}`;
        const switchIcon = new Image();
        switchIcon.src = `data:image/svg+xml,${encodeURIComponent(`<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-server"><rect x="2" y="2" width="20" height="8" rx="2" ry="2"></rect><rect x="2" y="14" width="20" height="8" rx="2" ry="2"></rect><line x1="6" y1="6" x2="6.01" y2="6"></line><line x1="6" y1="18" x2="6.01" y2="18"></line></svg>`)}`;

        // --- Canvas & Drawing Functions ---
        function resizeCanvas() {
            const container = canvas.parentElement;
            canvas.width = container.clientWidth;
            canvas.height = canvas.width * 0.6; // Maintain aspect ratio
            draw();
        }

        function draw() {
            if (!state.topology) return;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw links first
            state.links.forEach(link => {
                ctx.beginPath();
                ctx.moveTo(link.from.x, link.from.y);
                ctx.lineTo(link.to.x, link.to.y);
                ctx.strokeStyle = link.broken ? '#ef4444' : '#9ca3af';
                ctx.lineWidth = link.broken ? 4 : 3;
                ctx.setLineDash(link.broken ? [5, 5] : []);
                ctx.stroke();
                ctx.setLineDash([]);
            });

            // Draw nodes
            state.nodes.forEach(node => {
                ctx.drawImage(computerIcon, node.x - 20, node.y - 20, 40, 40);
                ctx.fillStyle = '#1f2937';
                ctx.font = 'bold 14px Inter';
                ctx.textAlign = 'center';
                ctx.fillText(`PC-${node.id}`, node.x, node.y + 35);
            });

            // Draw hub for star topology
            if (state.topology === 'star' && state.hub) {
                ctx.drawImage(switchIcon, state.hub.x - 25, state.hub.y - 25, 50, 50);
                if(state.hub.broken){
                    ctx.strokeStyle = '#ef4444';
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    ctx.moveTo(state.hub.x - 20, state.hub.y - 20);
                    ctx.lineTo(state.hub.x + 20, state.hub.y + 20);
                    ctx.moveTo(state.hub.x + 20, state.hub.y - 20);
                    ctx.lineTo(state.hub.x - 20, state.hub.y + 20);
                    ctx.stroke();
                }
            }

            // Draw packet
            if (state.packet) {
                ctx.beginPath();
                ctx.arc(state.packet.x, state.packet.y, 8, 0, Math.PI * 2);
                ctx.fillStyle = state.packet.color || '#10b981';
                ctx.fill();
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 2;
                ctx.stroke();
            }
        }

        // --- Topology Generation ---
        function generateTopology(type) {
            cancelAnimation();
            state.topology = type;
            state.nodes = [];
            state.links = [];
            state.hub = null;
            state.packet = null;
            state.mode = 'normal';
            
            const { width, height } = canvas;
            const centerX = width / 2;
            const centerY = height / 2;
            
            switch (type) {
                case 'bus':
                    const busY = centerY;
                    const busMargin = 0.15 * width;
                    const busLength = width - 2 * busMargin;
                    state.links.push({ from: {x: busMargin, y: busY}, to: {x: width - busMargin, y: busY}, isBus: true });
                    for (let i = 0; i < state.numNodes; i++) {
                        const nodeX = busMargin + (i + 0.5) * (busLength / state.numNodes);
                        const nodeY = busY + 80;
                        const node = { id: i, x: nodeX, y: nodeY };
                        state.nodes.push(node);
                        state.links.push({ from: {x: nodeX, y: busY}, to: node });
                    }
                    break;
                case 'star':
                    state.hub = { x: centerX, y: centerY, broken: false };
                    const starRadius = Math.min(width, height) * 0.35;
                    for (let i = 0; i < state.numNodes; i++) {
                        const angle = (i / state.numNodes) * 2 * Math.PI;
                        const node = { id: i, x: centerX + starRadius * Math.cos(angle), y: centerY + starRadius * Math.sin(angle) };
                        state.nodes.push(node);
                        state.links.push({ from: state.hub, to: node, broken: false });
                    }
                    break;
                case 'ring':
                    const ringRadius = Math.min(width, height) * 0.35;
                    for (let i = 0; i < state.numNodes; i++) {
                        const angle = (i / state.numNodes) * 2 * Math.PI;
                        state.nodes.push({ id: i, x: centerX + ringRadius * Math.cos(angle), y: centerY + ringRadius * Math.sin(angle) });
                    }
                    for (let i = 0; i < state.numNodes; i++) {
                        state.links.push({ from: state.nodes[i], to: state.nodes[(i + 1) % state.numNodes], broken: false });
                    }
                    break;
                case 'mesh':
                    const meshRadius = Math.min(width, height) * 0.35;
                     for (let i = 0; i < state.numNodes; i++) {
                        const angle = (i / state.numNodes) * 2 * Math.PI;
                        state.nodes.push({ id: i, x: centerX + meshRadius * Math.cos(angle), y: centerY + meshRadius * Math.sin(angle) });
                    }
                    for (let i = 0; i < state.numNodes; i++) {
                        for (let j = i + 1; j < state.numNodes; j++) {
                            state.links.push({ from: state.nodes[i], to: state.nodes[j], broken: false });
                        }
                    }
                    break;
            }
            updateInfoPanel(type);
            draw();
        }

        // --- UI Update ---
        function updateInfoPanel(type) {
            const info = topologyInfo[type];
            infoTitle.textContent = info.title;
            infoDescription.textContent = info.description;
            
            const prosConsHtml = `
                <div class="mt-4">
                    <h4 class="font-semibold text-green-600">Advantages:</h4>
                    <ul class="list-disc list-inside text-gray-600 mt-1">
                        ${info.pros.map(p => `<li>${p}</li>`).join('')}
                    </ul>
                </div>
                <div class="mt-4">
                    <h4 class="font-semibold text-red-600">Disadvantages:</h4>
                    <ul class="list-disc list-inside text-gray-600 mt-1">
                        ${info.cons.map(c => `<li>${c}</li>`).join('')}
                    </ul>
                </div>
            `;
            infoProsCons.innerHTML = prosConsHtml;
        }

        function setStatus(text, isError = false) {
            statusText.textContent = text;
            statusText.parentElement.parentElement.classList.toggle('bg-red-100', isError);
            statusText.parentElement.parentElement.classList.toggle('text-red-700', isError);
            statusText.parentElement.parentElement.classList.toggle('bg-gray-100', !isError);
            statusText.parentElement.parentElement.classList.toggle('text-gray-700', !isError);
        }

        // --- Animation & Simulation ---
        function animatePacket() {
            if (!state.packet) return;

            const { packet } = state;
            const dx = packet.target.x - packet.x;
            const dy = packet.target.y - packet.y;
            const dist = Math.sqrt(dx * dx + dy * dy);

            if (dist < packet.speed) {
                // Reached current target
                packet.path.shift(); // Remove current target from path
                if (packet.path.length === 0) {
                    // Reached final destination
                    setStatus(`Packet successfully delivered from PC-${packet.source.id} to PC-${packet.dest.id}.`);
                    state.packet = null;
                    draw();
                    return;
                }
                // Set next target
                packet.target = packet.path[0];
            } else {
                // Move towards target
                packet.x += (dx / dist) * packet.speed;
                packet.y += (dy / dist) * packet.speed;
            }

            draw();
            state.animationFrameId = requestAnimationFrame(animatePacket);
        }
        
        function cancelAnimation() {
            if (state.animationFrameId) {
                cancelAnimationFrame(state.animationFrameId);
                state.animationFrameId = null;
            }
        }

        function sendPacket(source, dest) {
            cancelAnimation();
            state.packet = null;
            let path = [];
            let deliveryFailed = false;
            let failureReason = "";

            switch (state.topology) {
                case 'star':
                    const linkToHub = state.links.find(l => l.to === source || l.from === source);
                    const linkFromHub = state.links.find(l => l.to === dest || l.from === dest);
                    if (state.hub.broken) {
                        deliveryFailed = true;
                        failureReason = "Central hub has failed. Network is down.";
                    } else if (linkToHub.broken || linkFromHub.broken) {
                        deliveryFailed = true;
                        failureReason = "A required connection to the hub is broken.";
                    } else {
                        path = [state.hub, dest];
                    }
                    break;
                case 'bus':
                    const busLink = state.links.find(l => l.isBus);
                    if (busLink.broken) {
                        deliveryFailed = true;
                        failureReason = "Main bus cable has failed. Network is down.";
                    } else {
                        const sourceDrop = state.links.find(l => l.to === source);
                        const destDrop = state.links.find(l => l.to === dest);
                        if (sourceDrop.broken || destDrop.broken) {
                            deliveryFailed = true;
                            failureReason = `Connection for PC-${sourceDrop.broken ? source.id : dest.id} is broken.`;
                        } else {
                            path = [{x: source.x, y: sourceDrop.from.y}, {x: dest.x, y: destDrop.from.y}, dest];
                        }
                    }
                    break;
                case 'ring':
                    let currentNode = source;
                    let nextNodeIndex = (source.id + 1) % state.numNodes;
                    let pathFound = false;
                    for(let i = 0; i < state.numNodes; i++) {
                        const currentLink = state.links.find(l => l.from.id === currentNode.id && l.to.id === nextNodeIndex);
                        if (currentLink.broken) {
                            deliveryFailed = true;
                            failureReason = `Link between PC-${currentNode.id} and PC-${nextNodeIndex} is broken. Ring is down.`;
                            break;
                        }
                        path.push(state.nodes[nextNodeIndex]);
                        if (nextNodeIndex === dest.id) {
                            pathFound = true;
                            break;
                        }
                        currentNode = state.nodes[nextNodeIndex];
                        nextNodeIndex = (nextNodeIndex + 1) % state.numNodes;
                    }
                    if (!pathFound && !deliveryFailed) { // Should not happen in a valid ring
                         deliveryFailed = true;
                         failureReason = "Could not find a path.";
                    }
                    break;
                case 'mesh':
                    const directLink = state.links.find(l => (l.from === source && l.to === dest) || (l.from === dest && l.to === source));
                    if (directLink && !directLink.broken) {
                        path = [dest];
                    } else {
                        // Simple BFS for alternative path
                        let q = [[source, [source]]];
                        let visited = new Set([source.id]);
                        let foundPath = null;

                        while(q.length > 0) {
                            let [current, p] = q.shift();
                            if (current.id === dest.id) {
                                foundPath = p;
                                break;
                            }
                            // Get neighbors
                            state.links.forEach(link => {
                                if (!link.broken) {
                                    let neighbor = null;
                                    if(link.from.id === current.id) neighbor = link.to;
                                    if(link.to.id === current.id) neighbor = link.from;
                                    
                                    if(neighbor && !visited.has(neighbor.id)) {
                                        visited.add(neighbor.id);
                                        let newPath = [...p, neighbor];
                                        q.push([neighbor, newPath]);
                                    }
                                }
                            });
                        }
                        if (foundPath) {
                            path = foundPath.slice(1); // remove source node
                        } else {
                            deliveryFailed = true;
                            failureReason = "No available path found between nodes.";
                        }
                    }
                    break;
            }

            if (deliveryFailed) {
                setStatus(failureReason, true);
                state.packet = { x: source.x, y: source.y, color: '#ef4444' }; // Show failed packet
                draw();
                setTimeout(() => { state.packet = null; draw(); }, 1500);
            } else {
                state.packet = {
                    x: source.x,
                    y: source.y,
                    source: source,
                    dest: dest,
                    path: path,
                    target: path[0],
                    speed: 4,
                };
                setStatus(`Sending packet from PC-${source.id} to PC-${dest.id}...`);
                animatePacket();
            }
        }


        // --- Event Handlers ---
        topologyButtons.addEventListener('click', (e) => {
            if (e.target.tagName === 'BUTTON') {
                const type = e.target.dataset.type;
                if (type) {
                    // Update active button style
                    document.querySelectorAll('#topology-buttons button').forEach(b => b.classList.remove('active'));
                    e.target.classList.add('active');
                    generateTopology(type);
                    setStatus('Ready');
                }
            }
        });

        sendPacketBtn.addEventListener('click', () => {
            if (!state.topology) {
                setStatus('Please select a topology first.', true);
                return;
            }
            state.mode = 'select-source';
            setStatus('Click on the source computer.');
        });
        
        breakLinkBtn.addEventListener('click', () => {
             if (!state.topology) {
                setStatus('Please select a topology first.', true);
                return;
            }
            state.mode = 'break-link';
            setStatus('Click on a connection or central hub to break it.');
        });

        resetBtn.addEventListener('click', () => {
            if (state.topology) {
                generateTopology(state.topology);
                setStatus('Network reset.');
            }
        });

        canvas.addEventListener('click', (e) => {
            if (!state.topology) return;
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            const clickedNode = state.nodes.find(node => Math.hypot(node.x - x, node.y - y) < 25);

            switch (state.mode) {
                case 'select-source':
                    if (clickedNode) {
                        state.sourceNode = clickedNode;
                        state.mode = 'select-dest';
                        setStatus(`Source is PC-${clickedNode.id}. Now click the destination computer.`);
                    }
                    break;
                case 'select-dest':
                    if (clickedNode) {
                        if (clickedNode.id === state.sourceNode.id) {
                            setStatus('Destination cannot be the same as the source. Select a different computer.', true);
                        } else {
                            state.destNode = clickedNode;
                            state.mode = 'normal';
                            sendPacket(state.sourceNode, state.destNode);
                        }
                    }
                    break;
                case 'break-link':
                    let componentBroken = false;
                    // Check for hub click in star topology
                    if (state.topology === 'star' && Math.hypot(state.hub.x - x, state.hub.y - y) < 30) {
                        state.hub.broken = !state.hub.broken;
                        componentBroken = true;
                        setStatus(`Central hub has been ${state.hub.broken ? 'broken' : 'repaired'}.`);
                    } else {
                        // Check for link click
                        for (const link of state.links) {
                            // Simple distance to line segment check
                            const dx = link.to.x - link.from.x;
                            const dy = link.to.y - link.from.y;
                            const lenSq = dx * dx + dy * dy;
                            const t = ((x - link.from.x) * dx + (y - link.from.y) * dy) / lenSq;
                            const tClamped = Math.max(0, Math.min(1, t));
                            const closestX = link.from.x + tClamped * dx;
                            const closestY = link.from.y + tClamped * dy;
                            if (Math.hypot(x - closestX, y - closestY) < 10) {
                                link.broken = !link.broken;
                                componentBroken = true;
                                setStatus(`A connection has been ${link.broken ? 'broken' : 'repaired'}.`);
                                break;
                            }
                        }
                    }
                    
                    if (componentBroken) {
                        draw();
                        state.mode = 'normal';
                    }
                    break;
            }
        });

        // --- Initial Setup ---
        window.addEventListener('resize', resizeCanvas);
        // Set initial state
        document.querySelector('#topology-buttons button[data-type="star"]').click();
        resizeCanvas(); // Initial call
        computerIcon.onload = draw;
        switchIcon.onload = draw;
    });
    </script>
</body>
</html>
